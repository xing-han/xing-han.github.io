<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=yes"/>
    <link href="/main.css" rel="stylesheet" type="text/css">
    <link href="/codehighlight.css" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="/images/logo.bmp">
    <title></title>
</head>
<body>
  <div class="content">
  <h1>算法概念</h1>

<p>为什么要叫算法概念呢? 因为算法本身不重要重要的是解决那个问题用到的思想. 就和设计模式一样, 重要的是patten</p>

<h2>回溯算法</h2>

<h3><a href="https://zh.wikipedia.org/wiki/回溯法">定义</a></h3>

<p>backtracking是暴力搜索法中的一种。相比于暴力搜索.</p>

<p>对于某些计算问题而言，回溯法是一种可以找出所有（或一部分）解的一般性算法，尤其适用于约束满足问题（在解决约束满足问题时，</p>

<p>递归到最后的返回条件是:</p>

<ul>
<li>找到一个可能存在的正确的答案</li>
<li>在尝试了所有可能的分步方法后宣告该问题没有答案</li>
</ul>

<h3>思想</h3>

<p>试错 约束编程 回溯</p>

<p>回溯是说当不满足条件的时候回到刚才的 <strong>状态</strong> .值得注意的是这个状态返回到之前的状态有两种做法,一种是自顶而下拷贝,这样子方法结束立马就丢掉了子方法的状态. 一种是维护一个全局变量.</p>

<p>一旦在过程中发现当前的部分解不满足约束条件,那么就不需要这个部分解后面的拓展出来的其他解(子集), 直接扔掉就好了. 这样大大优化了空间复杂度.</p>

<p>在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。</p>

<h3>例子</h3>

<p>八皇后问题, 暴力的解法是生成整个棋盘上所有可能的解法(N^N). 这个解法产生了太多无用的解, 比如第一行和第二行的皇后就冲突了, 就没必要在探索下面的可能性了.</p>

<p>这时候回溯法通过 <strong>约束</strong> + <strong>回溯</strong> 就解决了这个问题. 当部分解已经不满足的时候就向前看不需要探索其子集.</p>

<h3>模板</h3>

<pre><code>void backtrack(level int, stats collector, ans collector, ...)
{
    if(已经得到正确解){
      ans = ans.append(answer.copy());
      return;
    }
    // 下面的意思是在level这一层, 遍历所有的可行解
    // 空间. 这个地方需要仔细
    for(i of solution space)
    {
      backtrack(i+1,n,other parameters);
    }
}
</code></pre>

  </div>
</body>
<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106796420-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());
  gtag('config', 'UA-106796420-1');
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2e8594e80b736182ce88fcd89a36402d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</html>