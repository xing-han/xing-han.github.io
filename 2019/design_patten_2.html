<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0 user-scalable=yes"/>
    <link href="/main.css" rel="stylesheet" type="text/css">
    <link href="/codehighlight.css" rel="stylesheet" type="text/css">
    <link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Atom feed">
    <link rel="shortcut icon" href="/images/logo.bmp">
    <title></title>
</head>
<body>
  <div class="content">
  <h1>精进设计模式</h1>

<p>[toc]</p>

<h2>装饰器模式</h2>

<p>装饰器模式和代理模式最大的在代码上的区别就是. 被装饰函数一旦被装饰, 那么两者就合二为一了, 就是说如果被装饰函数递归调用自己, 就要变成递归调用这个整体.</p>

<h2>模板模式</h2>

<h2>工厂模式</h2>

<p>就是让你可以动态的创建对象, 纯粹是技术上的概念</p>

<h2>抽象工厂</h2>

<p>将多个工厂绑定在一起, 生产就生产一批产品. 用来提高内聚.</p>

<p>比如生产AK枪和AK子弹的两个工厂绑定在一起, 变成一个AK制造厂, 制造厂的职责就是生成一套完整的枪. 客户不在需要了解怎么配套!</p>

<p>从代码上就是解决了, 多个目标值相同的<code>switch case</code>的出现.</p>

<h2>策略模式</h2>

<p>结构:</p>

<ul>
<li>策略</li>
<li>具体策略</li>
<li>context</li>
</ul>

<pre><code>main {
    swich x{
        case A:
            foo1()
        case B:
            foo2()
    }
    公共流程
    switch x{
        case A:
            bar1()
        case B:
            bar2()
    }
}
</code></pre>

<p>协作:</p>

<p>context和策略相互作用以选定特定的算法.然后context负责提供算法需要的数据.</p>

<ul>
<li>客户会把具体策略传递给context. 然后只与context进行交互</li>
<li>客户讲一些参数传给context, 然后由context来选择调用什么样子的策略</li>
<li>甚至和抽象工厂模式结合在一起, 一个context提供多个策略</li>
</ul>

  </div>
</body>
<!-- Global Site Tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-106796420-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments)};
  gtag('js', new Date());
  gtag('config', 'UA-106796420-1');
</script>
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?2e8594e80b736182ce88fcd89a36402d";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>
</html>